package internal

import (
	"fmt"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/descriptorpb"
	"regexp"
	"strings"
)

func GenerateTsFile(gen *protogen.Plugin, file *protogen.File, tsDir string) *protogen.GeneratedFile {
	if len(file.Services) == 0 {
		return nil
	}
	names := strings.Split(file.GeneratedFilenamePrefix, "/")
	filename := tsDir + "/" + names[len(names)-1] + ".pb.ts"
	dir := protogen.GoImportPath(tsDir)
	g := gen.NewGeneratedFile(filename, dir)
	g.P("// Code generated by protoc-gen-bic. DO NOT EDIT.")
	g.P("// versions: ", VERSION)

	g.P()
	g.P("import { ResponseResult } from '../wxAjax'")
	g.P("import request from '../wxAjax'")
	g.P()
	generateTsFileContent(gen, file, g, false)
	return g
}
func generateTsFileContent(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile, omitempty bool) {
	if len(file.Services) == 0 {
		return
	}
	// 生成对象
	for _, service := range file.Services {
		//g.P("export function", service.GoName, " struct {")
		//g.P("    xx ", service.GoName)
		//g.P("}")
		//g.P()
		genTsApi(gen, file, g, service, omitempty)
		g.P()
	}
}

var tsTypeMap = map[protoreflect.Kind]string{
	protoreflect.BoolKind:     "boolean",
	protoreflect.Uint32Kind:   "number",
	protoreflect.Int32Kind:    "number",
	protoreflect.Uint64Kind:   "number",
	protoreflect.Int64Kind:    "number",
	protoreflect.FloatKind:    "number",
	protoreflect.DoubleKind:   "number",
	protoreflect.Fixed64Kind:  "number",
	protoreflect.Fixed32Kind:  "number",
	protoreflect.Sfixed64Kind: "number",
	protoreflect.Sfixed32Kind: "number",
	protoreflect.StringKind:   "string",
}

// TODO 其他类型
//BoolKind     Kind = 8
//EnumKind     Kind = 14
//BytesKind    Kind = 12
//MessageKind  Kind = 11
//GroupKind    Kind = 10

func getTsFieldName(kindName string, required bool) string {
	if required {
		return kindName
	} else {
		return kindName + "?"
	}
}

func getTsFieldType(file *protogen.File, field *protogen.Field, required, isList bool) string {
	kindName := ""
	if tsType, ok := tsTypeMap[field.Desc.Kind()]; ok {
		kindName = tsType
	} else if field.Desc.Kind() == protoreflect.MessageKind {
		kindName = "I" + field.Message.GoIdent.GoName
	} else if field.Desc.Kind() == protoreflect.EnumKind {
		kindName = "E" + string(field.Enum.GoIdent.GoName)
	} else {
		kindName = "I" + field.Desc.Kind().String()
	}
	if isList {
		if required {
			return fmt.Sprintf("%s[]", kindName)
		} else {
			return fmt.Sprintf("(%s[] | null)", kindName)
		}
	} else {
		if required {
			return kindName
		} else {
			return fmt.Sprintf("(%s | null)", kindName)
		}
	}
}

var interfaceCache = map[string]bool{}

type TsField struct {
	fieldName string
	fieldType string
	trailing  string
	Required  bool
	IsList    bool
	totalLen  int
}

func (tf *TsField) ToString(maxLen int) string {
	space := ""
	for i := 0; i < maxLen-tf.totalLen; i++ {
		space += " "
	}
	return fmt.Sprintf("  %s: %s %s%s", tf.fieldName, tf.fieldType, space, tf.trailing)
}

type TsEnum struct {
	fieldName string
	number    string
	trailing  string
	lastOne   bool
}

func (te *TsEnum) GetLen() int {
	return len(te.fieldName) + len(te.number)
}
func (te *TsEnum) ToString(maxLen int) string {
	space := ""
	for i := 0; i < maxLen-te.GetLen(); i++ {
		space += " "
	}
	if te.lastOne {
		return fmt.Sprintf("  %s = %s  %s%s", te.fieldName, te.number, space, te.trailing)
	}
	return fmt.Sprintf("  %s = %s, %s%s", te.fieldName, te.number, space, te.trailing)
}

func genTsInterface(g *protogen.GeneratedFile, file *protogen.File, message *protogen.Message) {
	if g == nil || message == nil {
		return
	}
	if _, ok := interfaceCache[message.GoIdent.GoName]; !ok {
		for _, ff := range message.Fields {
			if ff.Desc.Kind() == protoreflect.MessageKind {
				genTsInterface(g, file, ff.Message)
				//g.P("export interface I", ff.Message.GoIdent.GoName, " {")
				//var fieldList []*TsField
				//var maxLen = 0
				//for _, field := range ff.Message.Fields {
				//	required := strings.Contains(field.Comments.Leading.String(), "required")
				//	tmp := &TsField{
				//		fieldName: getTsFieldName(string(field.Desc.Name()), required),
				//		fieldType: getTsFieldType(file, field, required, field.Desc.IsList()),
				//		trailing:  strings.TrimSpace(field.Comments.Trailing.String()),
				//		Required:  required,
				//		IsList:    field.Desc.IsList(),
				//	}
				//	if field.Desc.IsExtension() {
				//		tmp.trailing += " // Extension"
				//	}
				//	tmp.totalLen = len(tmp.fieldType) + len(tmp.fieldName)
				//	fieldList = append(fieldList, tmp)
				//	if tmp.totalLen > maxLen {
				//		maxLen = tmp.totalLen
				//	}
				//}
				//for _, v := range fieldList {
				//	g.P(v.ToString(maxLen))
				//}
				//g.P("}")
				//interfaceCache[ff.Message.GoIdent.GoName] = true
			} else if ff.Desc.Kind() == protoreflect.EnumKind {
				if _, ook := interfaceCache[ff.Enum.GoIdent.GoName]; !ook {
					g.P("export enum E", ff.Enum.GoIdent.GoName, " {")
					var enumLine []*TsEnum
					var maxLen = 0
					for i, v := range ff.Enum.Values {
						comments := strings.TrimSpace(v.Comments.Trailing.String())
						tmp := &TsEnum{string(v.Desc.Name()), fmt.Sprintf("%d", v.Desc.Number()), comments, i == len(ff.Enum.Values)-1}
						enumLine = append(enumLine, tmp)
						if tmp.GetLen() > maxLen {
							maxLen = tmp.GetLen()
						}
					}
					for _, v := range enumLine {
						g.P(v.ToString(maxLen))
					}
					g.P("}")
				}
				interfaceCache[ff.Enum.GoIdent.GoName] = true
			}
		}
		g.P("export interface I", message.GoIdent.GoName, " {")
		var fieldList []*TsField
		var maxLen = 0
		for _, field := range message.Fields {
			required := strings.Contains(field.Comments.Leading.String(), "required")
			tmp := &TsField{
				fieldName: getTsFieldName(string(field.Desc.Name()), required),
				fieldType: getTsFieldType(file, field, required, field.Desc.IsList()),
				trailing:  strings.TrimSpace(field.Comments.Trailing.String()),
				Required:  required,
				IsList:    field.Desc.IsList(),
			}
			if field.Desc.IsExtension() {
				tmp.trailing += " // Extension"
			}
			tmp.totalLen = len(tmp.fieldType) + len(tmp.fieldName)
			fieldList = append(fieldList, tmp)
			if tmp.totalLen > maxLen {
				maxLen = tmp.totalLen
			}
		}
		for _, v := range fieldList {
			g.P(v.ToString(maxLen))
		}
		g.P("}")
		g.P("")
	}
	interfaceCache[message.GoIdent.GoName] = true
}

func genTsMessage(file *protogen.File, g *protogen.GeneratedFile) {
	for _, v := range file.Messages {
		genTsInterface(g, file, v)
	}
}

func genTsEnum(file *protogen.File, g *protogen.GeneratedFile) {
	for _, enum := range file.Enums {
		// enum类型的完整类型名
		g.P("export enum E", enum.GoIdent.GoName, " {")
		var enumLine []*TsEnum
		var maxLen = 0
		for i, v := range enum.Values {
			comments := strings.TrimSpace(v.Comments.Trailing.String())
			tmp := &TsEnum{string(v.Desc.Name()), fmt.Sprintf("%d", v.Desc.Number()), comments, i == len(enum.Values)-1}
			enumLine = append(enumLine, tmp)
			if tmp.GetLen() > maxLen {
				maxLen = tmp.GetLen()
			}
		}
		for _, v := range enumLine {
			g.P(v.ToString(maxLen))
		}
		g.P("}")
		g.P("")
		interfaceCache[enum.GoIdent.GoName] = true
	}
}

func genTsApi(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile, service *protogen.Service, omitempty bool) {
	genTsEnum(file, g)
	genTsMessage(file, g)
	if service.Desc.Options().(*descriptorpb.ServiceOptions).GetDeprecated() {
		g.P("//")
		g.P(deprecationComment)
	}
	for _, value := range service.Methods {
		leading := value.Input.Comments.Leading.String()
		httpParam := parseRpcLeading(value.Comments.Leading.String(), value.GoName)
		g.P("/**")
		if httpParam.Summary != "" {
			g.P(" * ", httpParam.Summary)
		} else if len(leading) > 2 {
			g.P(" * ", strings.TrimSpace(leading[2:]))
		}
		for _, p := range httpParam.UrlParamList {
			g.P(" * @Param ", p.pName, " - ", p.pType, ` id`)
		}
		if value.Input.GoIdent.GoName != "CommonNil" {
			if httpParam.MethodName == "GET" {
				g.P(" * @param params - ")
			} else {
				g.P(" * @param data - ")
			}
		}
		g.P(" * @returns")
		g.P(" */")

		var URLParamStr []string
		if len(httpParam.UrlParamList) > 0 {
			for _, p := range httpParam.UrlParamList {
				if p.pType == StringType {
					URLParamStr = append(URLParamStr, p.pName+": string")
				} else {
					URLParamStr = append(URLParamStr, p.pName+": number")
				}
			}
		}
		getFlag := false
		postFlag := false
		if value.Input.GoIdent.GoName != "CommonNil" {
			if httpParam.MethodName == "GET" {
				getFlag = true
				URLParamStr = append(URLParamStr, "params: I"+value.Input.GoIdent.GoName)
			} else {
				postFlag = true
				URLParamStr = append(URLParamStr, "data: I"+value.Input.GoIdent.GoName)
			}
		}
		if len(URLParamStr) > 0 {
			g.P("export function ", value.GoName, "(", strings.Join(URLParamStr, ", "), ", success: (res: ResponseResult<I", value.Output.GoIdent.GoName, ">) => void)", " {")
		} else {
			g.P("export function ", value.GoName, "(success: (res: ResponseResult<I", value.Output.GoIdent.GoName, ">) => void) ", "{")
		}
		url := httpParam.Url
		delTypeRe := regexp.MustCompile(`:(\w+)/`)
		url = delTypeRe.ReplaceAllString(url, `" + $1 + "/`)

		delTypeRe = regexp.MustCompile(`:(\w+)$`)
		url = delTypeRe.ReplaceAllString(url, `" + $1`)

		g.P("  return request({")
		g.P("    url: \"", url, "\",")
		g.P("    success: success,")
		g.P("    method: \"", httpParam.MethodName, "\",")
		for _, v := range httpParam.ClientParamList {
			g.P(`    ` + v.Key + `: ` + v.Value + `,`)
		}
		if httpParam.Download {
			g.P(`    responseType: "blob",`)
			g.P(`    isDownLoadFile: true,`)

		}
		if getFlag {
			g.P("    params,")
		}
		if postFlag {
			g.P("    data,")
		}
		g.P("  })")
		g.P("} ")
		g.P()
	}
}
