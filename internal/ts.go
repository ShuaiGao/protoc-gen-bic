package internal

import (
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/types/descriptorpb"
	"regexp"
	"strings"
)

func GenerateTsFile(gen *protogen.Plugin, file *protogen.File, tsDir string) *protogen.GeneratedFile {
	if len(file.Services) == 0 {
		return nil
	}
	names := strings.Split(file.GeneratedFilenamePrefix, "/")
	filename := tsDir + "/" + names[len(names)-1] + ".pb.ts"
	dir := protogen.GoImportPath(tsDir)
	g := gen.NewGeneratedFile(filename, dir)
	g.P("// Code generated by protoc-gen-bic. DO NOT EDIT.")
	g.P("// versions:", VERSION)

	g.P()
	g.P("import request from '@/utils/axiosReq'")
	g.P("import { http } from './proto'")
	g.P()
	generateTsFileContent(gen, file, g, false)
	return g
}
func generateTsFileContent(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile, omitempty bool) {
	if len(file.Services) == 0 {
		return
	}
	// 生成对象
	for _, service := range file.Services {
		//g.P("export function", service.GoName, " struct {")
		//g.P("    xx ", service.GoName)
		//g.P("}")
		//g.P()
		genTsApi(gen, file, g, service, omitempty)
		g.P()
	}
}
func genTsApi(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile, service *protogen.Service, omitempty bool) {
	if service.Desc.Options().(*descriptorpb.ServiceOptions).GetDeprecated() {
		g.P("//")
		g.P(deprecationComment)
	}
	for _, value := range service.Methods {
		leading := value.Input.Comments.Leading.String()
		httpParam := parseRpcLeading(value.Comments.Leading.String(), value.GoName)
		g.P("/**")
		if httpParam.Summary != "" {
			g.P(" * ", httpParam.Summary)
		} else if len(leading) > 2 {
			g.P(" * ", strings.TrimSpace(leading[2:]))
		}
		for _, p := range httpParam.UrlParamList {
			g.P(" * @Param ", p.pName, " - ", p.pType, ` id`)
		}
		if value.Input.GoIdent.GoName != "CommonNil" {
			if httpParam.MethodName == "GET" {
				g.P(" * @param params - ")
			} else {
				g.P(" * @param data - ")
			}
		}
		g.P(" * @returns")
		g.P(" */")

		var URLParamStr []string
		if len(httpParam.UrlParamList) > 0 {
			for _, p := range httpParam.UrlParamList {
				if p.pType == StringType {
					URLParamStr = append(URLParamStr, p.pName+": string")
				} else {
					URLParamStr = append(URLParamStr, p.pName+": number")
				}
			}
		}
		getFlag := false
		postFlag := false
		if value.Input.GoIdent.GoName != "CommonNil" {
			if httpParam.MethodName == "GET" {
				getFlag = true
				URLParamStr = append(URLParamStr, "params: http.I"+value.Input.GoIdent.GoName)
			} else {
				postFlag = true
				URLParamStr = append(URLParamStr, "data: http.I"+value.Input.GoIdent.GoName)
			}
		}
		if len(URLParamStr) > 0 {
			g.P("export function ", value.GoName, "(", strings.Join(URLParamStr, ", "), ") ", "{")
		} else {
			g.P("export function ", value.GoName, "() ", "{")
		}
		url := httpParam.Url
		delTypeRe := regexp.MustCompile(`:(\w+)/`)
		url = delTypeRe.ReplaceAllString(url, `" + $1 + "/`)

		delTypeRe = regexp.MustCompile(`:(\w+)$`)
		url = delTypeRe.ReplaceAllString(url, `" + $1`)

		g.P("  return request({")
		g.P("    url: \"", url, "\",")
		g.P("    method: \"", httpParam.MethodName, "\",")
		for _, v := range httpParam.ClientParamList {
			g.P(`    ` + v.Key + `: ` + v.Value + `,`)
		}
		if getFlag {
			g.P("    params,")
		}
		if postFlag {
			g.P("    data,")
		}
		g.P("  })")
		g.P("} ")
		g.P()
	}
}
