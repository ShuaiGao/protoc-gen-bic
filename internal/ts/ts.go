package ts

import (
	"fmt"
	"github.com/ShuaiGao/protoc-gen-bic/internal/utils"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/descriptorpb"
	"regexp"
	"strings"
)

func generateTsFileInterface(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile) {
	genTsEnums(file, g)
	genTsMessage(file, g)
}

func GenerateTsFile(gen *protogen.Plugin, file *protogen.File, tsDir string) *protogen.GeneratedFile {
	names := strings.Split(file.GeneratedFilenamePrefix, "/")
	filename := tsDir + "/" + names[len(names)-1] + ".pb.ts"
	dir := protogen.GoImportPath(tsDir)
	g := gen.NewGeneratedFile(filename, dir)
	g.P("// Code generated by protoc-gen-bic. DO NOT EDIT.")
	g.P("// versions: ", utils.VERSION)
	g.P()
	if len(file.Services) != 0 {
		g.P("import request, { Response } from '@/utils/axiosReq'")
	}
	importMap := genTsPath(file)
	for k, v := range importMap {
		items := strings.Join(v, ", ")
		g.P("import { ", items, " } from '", k, "'")
	}
	g.P()
	//for _, e := range file.Extensions {
	//	g.P("// ", e.Location.Path)
	//}
	//g.P("// GoImportPath = ", file.GoImportPath)
	generateTsFileInterface(gen, file, g)
	g.P()
	generateTsFileContent(gen, file, g, false)
	return g
}

func generateTsFileContent(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile, omitempty bool) {
	if len(file.Services) == 0 {
		return
	}
	// 生成对象
	for _, service := range file.Services {
		//g.P("export function", service.GoName, " struct {")
		//g.P("    xx ", service.GoName)
		//g.P("}")
		//g.P()
		genTsApi(gen, file, g, service, omitempty)
		g.P()
	}
}

var tsTypeMap = map[protoreflect.Kind]string{
	protoreflect.BoolKind:     "boolean",
	protoreflect.Uint32Kind:   "number",
	protoreflect.Int32Kind:    "number",
	protoreflect.Uint64Kind:   "number",
	protoreflect.Int64Kind:    "number",
	protoreflect.FloatKind:    "number",
	protoreflect.DoubleKind:   "number",
	protoreflect.Fixed64Kind:  "number",
	protoreflect.Fixed32Kind:  "number",
	protoreflect.Sfixed64Kind: "number",
	protoreflect.Sfixed32Kind: "number",
	protoreflect.StringKind:   "string",
}

var tsUrlParamTypeMap = map[string]string{
	"uint":    "number",
	"int":     "number",
	"uint64":  "number",
	"int64":   "number",
	"uint32":  "number",
	"int32":   "number",
	"string":  "string",
	"float":   "number",
	"float32": "number",
	"float64": "number",
	"object":  "Object",
}

func getTsUrlParamTypeShow(pType string) string {
	return tsUrlParamTypeMap[strings.ToLower(pType)]
}

// TODO 其他类型
//BoolKind     Kind = 8
//EnumKind     Kind = 14
//BytesKind    Kind = 12
//MessageKind  Kind = 11
//GroupKind    Kind = 10

func getTsFieldName(kindName string, required bool) string {
	if required {
		return kindName
	} else {
		return kindName + "?"
	}
}

func getTsFieldType(file *protogen.File, field *protogen.Field, required, isList, isMap bool) string {
	kindName := ""
	if tsType, ok := tsTypeMap[field.Desc.Kind()]; ok {
		kindName = tsType
	} else if field.Desc.Kind() == protoreflect.MessageKind {
		kindName = "I" + field.Message.GoIdent.GoName
	} else if field.Desc.Kind() == protoreflect.EnumKind {
		kindName = "E" + string(field.Enum.GoIdent.GoName)
	} else {
		kindName = "I" + field.Desc.Kind().String()
	}
	if isList {
		return fmt.Sprintf("(%s[] | null)", kindName)
	} else if isMap {
		keyKind := tsTypeMap[field.Desc.MapKey().Kind()]
		valueKind := field.Desc.MapValue().Kind()
		valueKindStr := ""
		if tsType, ok := tsTypeMap[valueKind]; ok {
			valueKindStr = tsType
		} else if valueKind == protoreflect.MessageKind {
			valueKindStr = "I" + string(field.Desc.MapValue().Message().Name())
		} else if valueKind == protoreflect.EnumKind {
			valueKindStr = "E" + string(field.Desc.MapValue().Enum().Name())
		} else {
			valueKindStr = "NotSupport"
		}
		return fmt.Sprintf("{[k :%s]: %s} | null", keyKind, valueKindStr)
	} else {
		return fmt.Sprintf("(%s | null)", kindName)
	}
}

var interfaceCache = map[string]bool{}

type TsField struct {
	fieldName string
	fieldType string
	trailing  string
	Required  bool
	IsList    bool
	totalLen  int
}

func (tf *TsField) ToString(maxLen int) string {
	space := ""
	for i := 0; i < maxLen-tf.totalLen; i++ {
		space += " "
	}
	return fmt.Sprintf("  %s: %s %s%s", tf.fieldName, tf.fieldType, space, tf.trailing)
}

type TsEnum struct {
	fieldName string
	number    string
	trailing  string
	lastOne   bool
}

func (te *TsEnum) GetLen() int {
	return len(te.fieldName) + len(te.number)
}
func (te *TsEnum) ToString(maxLen int) string {
	space := ""
	for i := 0; i < maxLen-te.GetLen(); i++ {
		space += " "
	}
	if te.lastOne {
		return fmt.Sprintf("  %s = %s  %s%s", te.fieldName, te.number, space, te.trailing)
	}
	return fmt.Sprintf("  %s = %s, %s%s", te.fieldName, te.number, space, te.trailing)
}

var recursionMap = make(map[string]bool)

func getTsImportPath(path string) string {
	paths := strings.Split(path, "/")
	if len(paths) == 0 {
		return ""
	}
	path = paths[len(paths)-1]
	return "./" + strings.Replace(path, ".proto", ".pb", -1)
}

func genTsInterface(g *protogen.GeneratedFile, file *protogen.File, message *protogen.Message) (name string) {
	name = ""
	if g == nil || message == nil {
		return
	}
	if _, ok := interfaceCache[message.GoIdent.GoName]; !ok {
		for _, ff := range message.Fields {
			if ff.Desc.Kind() == protoreflect.MessageKind {
				key := ff.Message.GoIdent.String()
				genOk := recursionMap[key]
				recursionMap[key] = true
				if !genOk && !strings.Contains(key, "DataMapEntry") {
					genTsInterface(g, file, ff.Message)
				}
				//g.P("export interface I", ff.Message.GoIdent.GoName, " {")
				//var fieldList []*TsField
				//var maxLen = 0
				//for _, field := range ff.Message.Fields {
				//	required := strings.Contains(field.Comments.Leading.String(), "required")
				//	tmp := &TsField{
				//		fieldName: getTsFieldName(string(field.Desc.Name()), required),
				//		fieldType: getTsFieldType(file, field, required, field.Desc.IsList()),
				//		trailing:  strings.TrimSpace(field.Comments.Trailing.String()),
				//		Required:  required,
				//		IsList:    field.Desc.IsList(),
				//	}
				//	if field.Desc.IsExtension() {
				//		tmp.trailing += " // Extension"
				//	}
				//	tmp.totalLen = len(tmp.fieldType) + len(tmp.fieldName)
				//	fieldList = append(fieldList, tmp)
				//	if tmp.totalLen > maxLen {
				//		maxLen = tmp.totalLen
				//	}
				//}
				//for _, v := range fieldList {
				//	g.P(v.ToString(maxLen))
				//}
				//g.P("}")
				//interfaceCache[ff.Message.GoIdent.GoName] = true
			} else if ff.Desc.Kind() == protoreflect.EnumKind {
				if _, ook := interfaceCache[ff.Enum.GoIdent.GoName]; !ook {
					g.P("export enum E", ff.Enum.GoIdent.GoName, " {")
					var enumLine []*TsEnum
					var maxLen = 0
					for i, v := range ff.Enum.Values {
						comments := strings.TrimSpace(v.Comments.Trailing.String())
						tmp := &TsEnum{string(v.Desc.Name()), fmt.Sprintf("%d", v.Desc.Number()), comments, i == len(ff.Enum.Values)-1}
						enumLine = append(enumLine, tmp)
						if tmp.GetLen() > maxLen {
							maxLen = tmp.GetLen()
						}
					}
					for _, v := range enumLine {
						g.P(v.ToString(maxLen))
					}
					g.P("}")
				}
				interfaceCache[ff.Enum.GoIdent.GoName] = true
			}
		}
		name = "I" + message.GoIdent.GoName
		g.P("export interface I", message.GoIdent.GoName, " {")
		var fieldList []*TsField
		var maxLen = 0
		for _, field := range message.Fields {
			required := strings.Contains(field.Comments.Leading.String(), utils.Required)
			tmp := &TsField{
				fieldName: getTsFieldName(string(field.Desc.Name()), required),
				fieldType: getTsFieldType(file, field, required, field.Desc.IsList(), field.Desc.IsMap()),
				trailing:  strings.TrimSpace(field.Comments.Trailing.String()),
				Required:  required,
				IsList:    field.Desc.IsList(),
			}
			if field.Desc.IsExtension() {
				tmp.trailing += " // Extension"
			}
			tmp.totalLen = len(tmp.fieldType) + len(tmp.fieldName)
			fieldList = append(fieldList, tmp)
			if tmp.totalLen > maxLen {
				maxLen = tmp.totalLen
			}
		}
		for _, v := range fieldList {
			g.P(v.ToString(maxLen))
		}
		if len(fieldList) == 0 {
			g.P("  __placeholder__?: any")
		}
		g.P("}")
		g.P("")
	}
	interfaceCache[message.GoIdent.GoName] = true
	return
}

func genTsMessage(file *protogen.File, g *protogen.GeneratedFile) {
	for _, v := range file.Messages {
		genTsInterface(g, file, v)
	}
}

func appendPath(dataMap map[string][]string, path, item string) {
	if v, ok := dataMap[path]; !ok {
		dataMap[path] = []string{item}
	} else {
		for _, vv := range v {
			if vv == item {
				return
			}
		}
		dataMap[path] = append(v, item)
	}
}

func genTsPath(file *protogen.File) map[string][]string {
	var importCache = map[string][]string{}
	for _, message := range file.Messages {
		for _, field := range message.Fields {
			if field.Desc.IsMap() {
				valueKind := field.Desc.MapValue().Kind()
				if valueKind == protoreflect.MessageKind {
					messagePath := field.Desc.MapValue().Message().ParentFile().Path()
					if messagePath != file.Desc.Path() {
						appendPath(importCache, getTsImportPath(messagePath), "I"+string(field.Desc.MapValue().Message().Name()))
					}
				} else if valueKind == protoreflect.EnumKind {
					messagePath := field.Desc.MapValue().ParentFile().Path()
					if messagePath != file.Desc.Path() {
						appendPath(importCache, getTsImportPath(messagePath), "E"+string(field.Desc.MapValue().Enum().Name()))
					}
				}
			} else if field.Desc.IsList() {
				if field.Desc.Kind() == protoreflect.MessageKind {
					messagePath := field.Desc.Message().ParentFile().Path()
					if messagePath != file.Desc.Path() {
						appendPath(importCache, getTsImportPath(messagePath), "I"+string(field.Message.Desc.Name()))
					}
				} else if field.Desc.Kind() == protoreflect.EnumKind {
					enumPath := field.Desc.Enum().ParentFile().Path()
					if enumPath != file.Desc.Path() {
						appendPath(importCache, getTsImportPath(enumPath), "E"+field.Enum.GoIdent.GoName)
					}
				}
			} else if field.Desc.Kind() == protoreflect.MessageKind {
				messagePath := field.Message.Desc.ParentFile().Path()
				if messagePath != file.Desc.Path() {
					appendPath(importCache, getTsImportPath(messagePath), "I"+field.Message.GoIdent.GoName)
				}
			} else if field.Desc.Kind() == protoreflect.EnumKind {
				enumPath := field.Enum.Desc.ParentFile().Path()
				if enumPath != file.Desc.Path() {
					appendPath(importCache, getTsImportPath(enumPath), "E"+field.Enum.GoIdent.GoName)
				}
			}
		}
	}
	for _, service := range file.Services {
		for _, method := range service.Methods {
			inputPath := method.Input.Desc.ParentFile().Path()
			if inputPath != file.Desc.Path() {
				appendPath(importCache, getTsImportPath(inputPath), "I"+method.Input.GoIdent.GoName)
			}
			outputPath := method.Output.Desc.ParentFile().Path()
			if outputPath != file.Desc.Path() {
				appendPath(importCache, getTsImportPath(outputPath), "I"+method.Output.GoIdent.GoName)
			}
		}
	}
	return importCache
}

func genTsEnum(g *protogen.GeneratedFile, enum *protogen.Enum) {
	// enum类型的完整类型名
	g.P(strings.TrimSpace(enum.Comments.Leading.String()))
	g.P("export enum E", enum.GoIdent.GoName, " {")
	var enumLine []*TsEnum
	var maxLen = 0
	for i, v := range enum.Values {
		comments := strings.TrimSpace(v.Comments.Trailing.String())
		tmp := &TsEnum{string(v.Desc.Name()), fmt.Sprintf("%d", v.Desc.Number()), comments, i == len(enum.Values)-1}
		enumLine = append(enumLine, tmp)
		if tmp.GetLen() > maxLen {
			maxLen = tmp.GetLen()
		}
	}
	for _, v := range enumLine {
		g.P(v.ToString(maxLen))
	}
	g.P("}")
	g.P("")
	interfaceCache[enum.GoIdent.GoName] = true
}

func genTsEnums(file *protogen.File, g *protogen.GeneratedFile) {
	for _, enum := range file.Enums {
		genTsEnum(g, enum)
	}
}

func genTsApi(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile, service *protogen.Service, omitempty bool) {
	if service.Desc.Options().(*descriptorpb.ServiceOptions).GetDeprecated() {
		g.P("//")
		g.P(utils.DeprecationComment)
	}
	for _, value := range service.Methods {
		leading := value.Input.Comments.Leading.String()
		httpParam := utils.ParseRpcLeading(value.Comments.Leading.String(), value.GoName)
		if len(httpParam.UrlParamList) > 0 {
			g.P("/**")
			if httpParam.Summary != "" {
				g.P(" * ", httpParam.Summary)
			} else if len(leading) > 2 {
				g.P(" * ", strings.TrimSpace(leading[2:]))
			}
			for _, p := range httpParam.UrlParamList {
				g.P(" * @Param { ", getTsUrlParamTypeShow(p.PType), " } ", p.PName, " - ")
			}
			if value.Input.GoIdent.GoName != "CommonNil" || value.Input.GoIdent.GoName != "Empty" {
				if httpParam.MethodName == "GET" {
					//g.P(" * @param params - ")
				} else {
					//g.P(" * @param data - ")
				}
			}
			//g.P(" * @returns")
			g.P(" */")
		} else {
			g.P("// ", httpParam.Summary)
		}

		var URLParamStr []string
		if len(httpParam.UrlParamList) > 0 {
			for _, p := range httpParam.UrlParamList {
				if p.PType == utils.StringType {
					URLParamStr = append(URLParamStr, p.PName+": string")
				} else {
					URLParamStr = append(URLParamStr, p.PName+": number")
				}
			}
		}
		getFlag := false
		postFlag := false
		if value.Input.GoIdent.GoName != "CommonNil" && value.Input.GoIdent.GoName != "Empty" {
			if httpParam.MethodName == "GET" {
				getFlag = true
				URLParamStr = append(URLParamStr, "params: I"+value.Input.GoIdent.GoName)
			} else {
				postFlag = true
				URLParamStr = append(URLParamStr, "data: I"+value.Input.GoIdent.GoName)
			}
		}
		output := "I" + value.Output.GoIdent.GoName
		if len(URLParamStr) > 0 {
			g.P("export function ", value.GoName, "(", strings.Join(URLParamStr, ", "), "): Promise<Response<"+output+">> {")
		} else {
			g.P("export function ", value.GoName, "(): Promise<Response<"+output+">> {")
		}
		url := httpParam.Url
		delTypeRe := regexp.MustCompile(`:(\w+)/`)
		url = delTypeRe.ReplaceAllString(url, `" + $1 + "/`)

		delTypeRe = regexp.MustCompile(`:(\w+)$`)
		url = delTypeRe.ReplaceAllString(url, `" + $1`)

		g.P("  return request({")
		g.P("    url: \"", url, "\",")
		g.P("    method: \"", httpParam.MethodName, "\",")
		for _, v := range httpParam.ClientParamList {
			g.P(`    ` + v.Key + `: ` + v.Value + `,`)
		}
		if getFlag {
			g.P("    params,")
		}
		if postFlag {
			g.P("    data,")
		}
		g.P("  })")
		g.P("} ")
		g.P()
	}
}
