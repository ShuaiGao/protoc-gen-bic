package js

import (
	"fmt"
	"github.com/ShuaiGao/protoc-gen-bic/internal/utils"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/descriptorpb"
	"strings"
)

func appendPath(dataMap map[string][]string, path, item string) {
	if v, ok := dataMap[path]; !ok {
		dataMap[path] = []string{item}
	} else {
		for _, vv := range v {
			if vv == item {
				return
			}
		}
		dataMap[path] = append(v, item)
	}
}

func generateJsFileInterface(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile) {
	genJsEnums(file, g)
	//genJsMessage(file, g)
}

func GenerateJsFile(gen *protogen.Plugin, file *protogen.File, tsDir string) *protogen.GeneratedFile {
	names := strings.Split(file.GeneratedFilenamePrefix, "/")
	filename := tsDir + "/" + names[len(names)-1] + ".pb.js"
	dir := protogen.GoImportPath(tsDir)
	g := gen.NewGeneratedFile(filename, dir)
	g.P("// Code generated by protoc-gen-bic. DO NOT EDIT.")
	g.P("// versions: ", utils.VERSION)
	g.P()
	if len(file.Services) != 0 {
		g.P("import request from '@/utils/axiosReq'")
	}
	generateJsFileInterface(gen, file, g)
	g.P()
	generateJsFileContent(gen, file, g, false)
	return g
}

func generateJsFileContent(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile, omitempty bool) {
	if len(file.Services) == 0 {
		return
	}
	// 生成对象
	for _, service := range file.Services {
		serviceParam := utils.ParseServiceLeading(service.Comments.Leading.String())
		if serviceParam.Root != "" {
			g.P(`const UrlRoot = "`, serviceParam.Root, `";`)
		}
		genJsApi(gen, file, g, service, serviceParam)
		g.P()
	}
}

var jsTypeMap = map[protoreflect.Kind]string{
	protoreflect.BoolKind:     "boolean",
	protoreflect.Uint32Kind:   "number",
	protoreflect.Int32Kind:    "number",
	protoreflect.Uint64Kind:   "number",
	protoreflect.Int64Kind:    "number",
	protoreflect.FloatKind:    "number",
	protoreflect.DoubleKind:   "number",
	protoreflect.Fixed64Kind:  "number",
	protoreflect.Fixed32Kind:  "number",
	protoreflect.Sfixed64Kind: "number",
	protoreflect.Sfixed32Kind: "number",
	protoreflect.StringKind:   "string",
	protoreflect.MessageKind:  "Object",
	protoreflect.EnumKind:     "Object",
}

var urlParamTypeMap = map[string]string{
	"uint":    "number",
	"int":     "number",
	"uint64":  "number",
	"int64":   "number",
	"uint32":  "number",
	"int32":   "number",
	"string":  "string",
	"float":   "number",
	"float32": "number",
	"float64": "number",
	"object":  "Object",
}

func getJsUrlParamTypeShow(pType string) string {
	return urlParamTypeMap[strings.ToLower(pType)]
}

func getJsFieldName(kindName string, required bool) string {
	if required {
		return kindName
	} else {
		return kindName + "?"
	}
}

func getJsFieldType(file *protogen.File, field *protogen.Field, required, isList, isMap bool) string {
	kindName := ""
	if tsType, ok := jsTypeMap[field.Desc.Kind()]; ok {
		kindName = tsType
	} else if field.Desc.Kind() == protoreflect.MessageKind {
		kindName = "I" + field.Message.GoIdent.GoName
	} else if field.Desc.Kind() == protoreflect.EnumKind {
		kindName = "E" + string(field.Enum.GoIdent.GoName)
	} else {
		kindName = "I" + field.Desc.Kind().String()
	}
	if isList {
		if required {
			return fmt.Sprintf("%s[]", kindName)
		} else {
			return fmt.Sprintf("(%s[] | null)", kindName)
		}
	} else if isMap {
		keyKind := jsTypeMap[field.Desc.MapKey().Kind()]
		valueKind := field.Desc.MapValue().Kind()
		valueKindStr := ""
		if tsType, ok := jsTypeMap[valueKind]; ok {
			valueKindStr = tsType
		} else if valueKind == protoreflect.MessageKind {
			valueKindStr = "I" + string(field.Desc.MapValue().Message().Name())
		} else if valueKind == protoreflect.EnumKind {
			valueKindStr = "E" + string(field.Desc.MapValue().Enum().Name())
		} else {
			valueKindStr = "NotSupport"
		}
		if required {
			return fmt.Sprintf("{[k :%s]: %s}", keyKind, valueKindStr)
		} else {
			return fmt.Sprintf("{[k :%s]: %s} | null", keyKind, valueKindStr)
		}
	} else {
		if required {
			return kindName
		} else {
			return fmt.Sprintf("(%s | null)", kindName)
		}
	}
}

var interfaceCacheJs = map[string]bool{}

type JsField struct {
	fieldName string
	fieldType string
	trailing  string
	Required  bool
	IsList    bool
	totalLen  int
}

func (tf *JsField) ToString(maxLen int) string {
	space := ""
	for i := 0; i < maxLen-tf.totalLen; i++ {
		space += " "
	}
	return fmt.Sprintf("  %s: %s %s%s", tf.fieldName, tf.fieldType, space, tf.trailing)
}

type ApiParam struct {
	fieldFlag bool
	method    string
	name      string
	fieldType protoreflect.Kind
	fieldName string
	number    string
	trailing  string
	leading   string
}

func (te *ApiParam) GetLen() int {
	return len(te.fieldName) + len(te.number)
}
func (te *ApiParam) ToString(maxLen int) string {
	space := ""
	for i := 0; i < maxLen-te.GetLen(); i++ {
		space += " "
	}
	paramName := "params"
	if te.method == "POST" {
		paramName = "data"
	}

	required := strings.Contains(te.leading, utils.Required) || strings.Contains(te.trailing, utils.Required)
	if !te.fieldFlag {
		leading := strings.TrimSpace(strings.TrimLeft(te.leading, "/ "))
		return fmt.Sprintf(" * @param { Object } %s   %s - %s %s", paramName, space, te.name, leading)
	}
	trailing := strings.TrimSpace(strings.TrimLeft(te.trailing, "/ "))
	if required {
		return fmt.Sprintf(" * @param { %s } %s.%s  %s - %s", jsTypeMap[te.fieldType], paramName, te.fieldName, space, trailing)
	}
	return fmt.Sprintf(" * @param { ?%s } %s.%s %s - %s", jsTypeMap[te.fieldType], paramName, te.fieldName, space, trailing)
}

type JsEnum struct {
	fieldName string
	number    string
	trailing  string
	lastOne   bool
}

func (te *JsEnum) GetLen() int {
	return len(te.fieldName) + len(te.number)
}
func (te *JsEnum) ToString(maxLen int) string {
	space := ""
	for i := 0; i < maxLen-te.GetLen(); i++ {
		space += " "
	}
	if te.lastOne {
		return fmt.Sprintf("  %s: %s  %s%s", te.fieldName, te.number, space, te.trailing)
	}
	return fmt.Sprintf("  %s: %s, %s%s", te.fieldName, te.number, space, te.trailing)
}

var recursionMapJs = make(map[string]bool)

func getJsImportPath(path string) string {
	paths := strings.Split(path, "/")
	if len(paths) == 0 {
		return ""
	}
	path = paths[len(paths)-1]
	return "./" + strings.Replace(path, ".proto", ".pb", -1)
}

func genJsInterface(g *protogen.GeneratedFile, file *protogen.File, message *protogen.Message) (name string) {
	name = ""
	if g == nil || message == nil {
		return
	}
	if _, ok := interfaceCacheJs[message.GoIdent.GoName]; !ok {
		for _, ff := range message.Fields {
			if ff.Desc.Kind() == protoreflect.MessageKind {
				key := ff.Message.GoIdent.String()
				genOk := recursionMapJs[key]
				recursionMapJs[key] = true
				if !genOk && !strings.Contains(key, "DataMapEntry") {
					genJsInterface(g, file, ff.Message)
				}
				//g.P("export interface I", ff.Message.GoIdent.GoName, " {")
				//var fieldList []*JsField
				//var maxLen = 0
				//for _, field := range ff.Message.Fields {
				//	required := strings.Contains(field.Comments.Leading.String(), "required")
				//	tmp := &JsField{
				//		fieldName: getJsFieldName(string(field.Desc.Name()), required),
				//		fieldType: getJsFieldType(file, field, required, field.Desc.IsList()),
				//		trailing:  strings.TrimSpace(field.Comments.Trailing.String()),
				//		Required:  required,
				//		IsList:    field.Desc.IsList(),
				//	}
				//	if field.Desc.IsExtension() {
				//		tmp.trailing += " // Extension"
				//	}
				//	tmp.totalLen = len(tmp.fieldType) + len(tmp.fieldName)
				//	fieldList = append(fieldList, tmp)
				//	if tmp.totalLen > maxLen {
				//		maxLen = tmp.totalLen
				//	}
				//}
				//for _, v := range fieldList {
				//	g.P(v.ToString(maxLen))
				//}
				//g.P("}")
				//interfaceCacheJs[ff.Message.GoIdent.GoName] = true
			} else if ff.Desc.Kind() == protoreflect.EnumKind {
				if _, ook := interfaceCacheJs[ff.Enum.GoIdent.GoName]; !ook {
					genJsEnum(g, ff.Enum)
				}
				interfaceCacheJs[ff.Enum.GoIdent.GoName] = true

			}
		}
		name = "I" + message.GoIdent.GoName
		g.P("export interface I", message.GoIdent.GoName, " {")
		var fieldList []*JsField
		var maxLen = 0
		for _, field := range message.Fields {
			required := strings.Contains(field.Comments.Leading.String(), utils.Required)
			tmp := &JsField{
				fieldName: getJsFieldName(string(field.Desc.Name()), required),
				fieldType: getJsFieldType(file, field, required, field.Desc.IsList(), field.Desc.IsMap()),
				trailing:  strings.TrimSpace(field.Comments.Trailing.String()),
				Required:  required,
				IsList:    field.Desc.IsList(),
			}
			if field.Desc.IsExtension() {
				tmp.trailing += " // Extension"
			}
			tmp.totalLen = len(tmp.fieldType) + len(tmp.fieldName)
			fieldList = append(fieldList, tmp)
			if tmp.totalLen > maxLen {
				maxLen = tmp.totalLen
			}
		}
		for _, v := range fieldList {
			g.P(v.ToString(maxLen))
		}
		if len(fieldList) == 0 {
			g.P("  __placeholder__: any")
		}
		g.P("}")
		g.P("")
	}
	interfaceCacheJs[message.GoIdent.GoName] = true
	return
}

func genJsMessage(file *protogen.File, g *protogen.GeneratedFile) {
	for _, v := range file.Messages {
		genJsInterface(g, file, v)
	}
}

func appendPathJs(dataMap map[string][]string, path, item string) {
	if v, ok := dataMap[path]; !ok {
		dataMap[path] = []string{item}
	} else {
		for _, vv := range v {
			if vv == item {
				return
			}
		}
		dataMap[path] = append(v, item)
	}
}

func genJsPath(file *protogen.File) map[string][]string {
	var importCache = map[string][]string{}
	for _, message := range file.Messages {
		for _, field := range message.Fields {
			if field.Desc.IsMap() {
				valueKind := field.Desc.MapValue().Kind()
				if valueKind == protoreflect.MessageKind {
					messagePath := field.Desc.MapValue().Message().ParentFile().Path()
					if messagePath != file.Desc.Path() {
						appendPath(importCache, getJsImportPath(messagePath), "I"+string(field.Desc.MapValue().Message().Name()))
					}
				} else if valueKind == protoreflect.EnumKind {
					messagePath := field.Desc.MapValue().ParentFile().Path()
					if messagePath != file.Desc.Path() {
						appendPath(importCache, getJsImportPath(messagePath), "E"+string(field.Desc.MapValue().Enum().Name()))
					}
				}
			} else if field.Desc.IsList() {
				if field.Desc.Kind() == protoreflect.MessageKind {
					messagePath := field.Desc.Message().ParentFile().Path()
					if messagePath != file.Desc.Path() {
						appendPath(importCache, getJsImportPath(messagePath), "I"+string(field.Message.Desc.Name()))
					}
				} else if field.Desc.Kind() == protoreflect.EnumKind {
					enumPath := field.Desc.Enum().ParentFile().Path()
					if enumPath != file.Desc.Path() {
						appendPath(importCache, getJsImportPath(enumPath), "E"+field.Enum.GoIdent.GoName)
					}
				}
			} else if field.Desc.Kind() == protoreflect.MessageKind {
				messagePath := field.Message.Desc.ParentFile().Path()
				if messagePath != file.Desc.Path() {
					appendPath(importCache, getJsImportPath(messagePath), "I"+field.GoIdent.GoName)
				}
			} else if field.Desc.Kind() == protoreflect.EnumKind {
				enumPath := field.Enum.Desc.ParentFile().Path()
				if enumPath != file.Desc.Path() {
					appendPath(importCache, getJsImportPath(enumPath), "E"+field.Enum.GoIdent.GoName)
				}
			}
		}
	}
	for _, service := range file.Services {
		for _, method := range service.Methods {
			inputPath := method.Input.Desc.ParentFile().Path()
			if inputPath != file.Desc.Path() {
				appendPath(importCache, getJsImportPath(inputPath), "I"+method.Input.GoIdent.GoName)
			}
			outputPath := method.Output.Desc.ParentFile().Path()
			if outputPath != file.Desc.Path() {
				appendPath(importCache, getJsImportPath(outputPath), "I"+method.Output.GoIdent.GoName)
			}
		}
	}
	return importCache
}

func genJsEnums(file *protogen.File, g *protogen.GeneratedFile) {
	for _, enum := range file.Enums {
		genJsEnum(g, enum)
	}
}

func genJsEnum(g *protogen.GeneratedFile, enum *protogen.Enum) {
	// enum类型的完整类型名
	g.P("/**")
	if len(enum.Comments.Leading.String()) > 0 {
		g.P(" * ", strings.TrimSpace(strings.TrimLeft(enum.Comments.Leading.String(), "/ ")))
	}
	g.P(" * @readonly")
	g.P(" * @enum {number}")
	g.P(" */")
	g.P("const E", enum.GoIdent.GoName, " = {")
	var enumLine []*JsEnum
	var maxLen = 0
	for i, v := range enum.Values {
		comments := strings.TrimSpace(v.Comments.Trailing.String())
		tmp := &JsEnum{string(v.Desc.Name()), fmt.Sprintf("%d", v.Desc.Number()), comments, i == len(enum.Values)-1}
		enumLine = append(enumLine, tmp)
		if tmp.GetLen() > maxLen {
			maxLen = tmp.GetLen()
		}
	}
	for _, v := range enumLine {
		g.P(v.ToString(maxLen))
	}
	g.P("}")
	g.P("")
	interfaceCacheJs[enum.GoIdent.GoName] = true
}

func genJsApi(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile, service *protogen.Service, param utils.ServiceParam) {
	if service.Desc.Options().(*descriptorpb.ServiceOptions).GetDeprecated() {
		g.P("//")
		g.P(utils.DeprecationComment)
	}
	for _, value := range service.Methods {
		leading := value.Input.Comments.Leading.String()
		httpParam := utils.ParseRpcLeading(value.Comments.Leading.String(), value.GoName)
		g.P("/**")
		if httpParam.Summary != "" {
			g.P(" * ", httpParam.Summary)
		} else if len(leading) > 2 {
			g.P(" * ", strings.TrimSpace(leading[2:]))
		}
		for _, p := range httpParam.UrlParamList {
			g.P(" * @Param { ", getJsUrlParamTypeShow(p.PType), " } ", p.PName, " - ")
		}
		var ParamList []*ApiParam
		if value.Input.GoIdent.GoName != "CommonNil" || value.Input.GoIdent.GoName != "Empty" {
			ParamList = append(ParamList, &ApiParam{
				method: httpParam.MethodName,
				name:   value.Input.GoIdent.GoName,
				//leading: value.Input.Comments.Leading.String(),
			})
			maxLen := 0
			for _, v := range value.Input.Fields {
				t := &ApiParam{
					method:    httpParam.MethodName,
					fieldFlag: true,
					fieldType: v.Desc.Kind(),
					fieldName: v.Desc.JSONName(),
					leading:   v.Comments.Leading.String(),
					trailing:  strings.TrimSpace(v.Comments.Trailing.String()),
				}
				maxLen = utils.Max(maxLen, t.GetLen())
				ParamList = append(ParamList, t)
				//comments := strings.TrimSpace(v.Comments.Trailing.String())
				//jsTypeStr := jsTypeMap[v.Desc.Kind()]
				//if strings.Contains(v.Comments.Leading.String()+v.Comments.Trailing.String(), "required") {
				//	jsTypeStr = "!" + jsTypeStr
				//} else {
				//	jsTypeStr = "?" + jsTypeStr
				//}
				//g.P(" * @param { ", jsTypeStr, " } ", paramShow, ".", v.Desc.JSONName(), " - ", comments)
			}
			for _, v := range ParamList {
				g.P(v.ToString(maxLen))
			}
			g.P(" * @return { Promise } Promise object - ", value.Output.GoIdent.GoName)
		}
		g.P(" */")

		var URLParamStr []string
		if len(httpParam.UrlParamList) > 0 {
			for _, p := range httpParam.UrlParamList {
				if p.PType == utils.StringType {
					URLParamStr = append(URLParamStr, p.PName)
				} else {
					URLParamStr = append(URLParamStr, p.PName)
				}
			}
		}
		getFlag := false
		postFlag := false
		if value.Input.GoIdent.GoName != "CommonNil" && value.Input.GoIdent.GoName != "Empty" {
			if httpParam.MethodName == "GET" {
				getFlag = true
				URLParamStr = append(URLParamStr, "params")
			} else {
				postFlag = true
				URLParamStr = append(URLParamStr, "data")
			}
		}
		if len(URLParamStr) > 0 {
			g.P("export function ", value.GoName, "(", strings.Join(URLParamStr, ", "), ") {")
		} else {
			g.P("export function ", value.GoName, "() {")
		}
		g.P("  return request({")
		if param.Root != "" {
			g.P("    url: UrlRoot + ", httpParam.UrlJsTs, ",")
		} else {
			g.P("    url: ", httpParam.UrlJsTs, ",")
		}
		g.P("    method: \"", httpParam.MethodName, "\",")
		for _, v := range httpParam.ClientParamList {
			g.P(`    ` + v.Key + `: ` + v.Value + `,`)
		}
		if getFlag {
			g.P("    params,")
		}
		if postFlag {
			g.P("    data,")
		}
		g.P("  })")
		g.P("} ")
		g.P()
	}
}
