package internal

import (
	"fmt"
	"github.com/ShuaiGao/protoc-gen-bic/internal/utils"
	"go/ast"
	"go/parser"
	"go/token"
	"strings"
	"unicode"
	"unicode/utf8"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"

	"google.golang.org/protobuf/types/descriptorpb"
	"google.golang.org/protobuf/types/pluginpb"
)

// SupportedFeatures reports the set of supported protobuf language features.
var SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)
var PermissionPkg string

// GenerateFile generates the contents of a .pb.go file.
func GenerateFile(gen *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {
	return generateFile(gen, file, false)
}

func genImport(gen *protogen.Plugin, g *protogen.GeneratedFile, f *fileInfo, imp protoreflect.FileImport) {
	impFile, ok := gen.FilesByPath[imp.Path()]
	if !ok {
		return
	}
	if impFile.GoImportPath == f.GoImportPath {
		// Don't generate imports or aliases for types in the same Go package.
		return
	}
	// Generate imports for all non-weak dependencies, even if they are not
	// referenced, because other code and tools depend on having the
	// full transitive closure of protocol buffer types in the binary.
	if !imp.IsWeak {
		g.Import(impFile.GoImportPath)
	}
	if !imp.IsPublic {
		return
	}

	// Generate public imports by generating the imported file, parsing it,
	// and extracting every symbol that should receive a forwarding declaration.
	impGen := GenerateFile(gen, impFile)
	impGen.Skip()
	b, err := impGen.Content()
	if err != nil {
		gen.Error(err)
		return
	}
	fset := token.NewFileSet()
	astFile, err := parser.ParseFile(fset, "", b, parser.ParseComments)
	if err != nil {
		gen.Error(err)
		return
	}
	genForward := func(tok token.Token, name string, expr ast.Expr) {
		// Don't import unexported symbols.
		r, _ := utf8.DecodeRuneInString(name)
		if !unicode.IsUpper(r) {
			return
		}
		// Don't import the FileDescriptor.
		if name == impFile.GoDescriptorIdent.GoName {
			return
		}
		// Don't import decls referencing a symbol defined in another package.
		// i.e., don't import decls which are themselves public imports:
		//
		//	type T = somepackage.T
		if _, ok := expr.(*ast.SelectorExpr); ok {
			return
		}
		g.P(tok, " ", name, " = ", impFile.GoImportPath.Ident(name))
	}
	g.P("// Symbols defined in public import of ", imp.Path(), ".")
	g.P()
	for _, decl := range astFile.Decls {
		switch decl := decl.(type) {
		case *ast.GenDecl:
			for _, spec := range decl.Specs {
				switch spec := spec.(type) {
				case *ast.TypeSpec:
					genForward(decl.Tok, spec.Name.Name, spec.Type)
				case *ast.ValueSpec:
					for i, name := range spec.Names {
						var expr ast.Expr
						if i < len(spec.Values) {
							expr = spec.Values[i]
						}
						genForward(decl.Tok, name.Name, expr)
					}
				case *ast.ImportSpec:
				default:
					panic(fmt.Sprintf("can't generate forward for spec type %T", spec))
				}
			}
		}
	}
	g.P()
}

// generateFile generates a _http.pb.go file containing kratos errors definitions.
func generateFile(gen *protogen.Plugin, file *protogen.File, omitempty bool) *protogen.GeneratedFile {

	if len(file.Services) == 0 {
		return nil
	}
	filename := file.GeneratedFilenamePrefix + "_http.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	//f := newFileInfo(file)
	g.P("// Code generated by protoc-gen-bic. DO NOT EDIT.")
	g.P("// versions:", utils.VERSION)
	//for i, imps := 0, f.Desc.Imports(); i < imps.Len(); i++ {
	//	genImport(gen, g, f, imps.Get(i))
	//}
	g.P()
	g.P("package ", string(file.GoPackageName))
	generateFileContent(gen, file, g, omitempty)
	return g
}

// generateFileContent generates the kratos errors definitions, excluding the package statement.
func generateFileContent(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile, omitempty bool) {
	if len(file.Services) == 0 {
		return
	}
	g.P("// This is a compile-time assertion to ensure that this generated file")
	g.P("// is compatible with the kratos package it is being compiled against.")
	g.P("import (")

	needImportPermission := false
	needImportStrconv := false
	for _, service := range file.Services {
		for _, value := range service.Methods {
			httpParam := utils.ParseRpcLeading(string(value.Comments.Leading), value.GoName)
			if len(httpParam.Permission) > 0 {
				needImportPermission = true
			}
			for _, param := range httpParam.UrlParamList {
				if param.PType == utils.IntType || param.PType == utils.Int64Type || param.PType == utils.UIntType {
					needImportStrconv = true
				}
			}
		}
	}
	if needImportPermission {
		g.P(`"`, PermissionPkg, `"`)
	}

	g.P(`"net/http"`)

	if needImportStrconv {
		g.P(`"strconv"`)
	}

	paths := genImportService(gen, file, g, omitempty)
	for _, path := range paths {
		g.P(`"`, path, `"`)
	}
	g.P()
	g.P(`"github.com/gin-gonic/gin"`)
	//g.P(`"github.com/GodWY/bic/service"`)
	g.P(")")

	// 读取注释里的导入的包

	// 自动生成注册gin的何种方法
	for _, service := range file.Services {
		// 服务的注释
		serviceComments := string(service.Comments.Leading)
		// 获取服务组的middleWare
		var commentsArr = []string{}
		if strings.Contains(serviceComments, "@") {
			// middleWares = parserComment(serviceComments)
			commentsArr = strings.Split(serviceComments, "@")
		}
		si := parserComment(commentsArr)
		if si.ProjectUri == "" {
			si.ProjectUri = "/api"
		}
		g.P()
	}

	// 自动生成服务调用接口
	for _, service := range file.Services {
		g.P("func Register", service.GoName, "HttpHandler(g *gin.RouterGroup,", "srvs ", service.GoName, ") {")
		g.P("  tmp := &", "x_", service.GoName, "{ xx: srvs }")
		for _, value := range service.Methods {
			// g.Annotate(value.GoName, value.Location)
			// 读取注释
			// leadingComments := appendDeprecationSuffix("",
			// 	value.Desc.Options().(*descriptorpb.MethodOptions).GetDeprecated())
			a := string(value.Comments.Leading)
			httpParam := utils.ParseRpcLeading(a, value.GoName)
			// method := strings.Split(a, "@")
			// valuemiddleWares := parserComment(method[2:])
			if len(httpParam.Permission) > 0 {
				g.P("g.", httpParam.MethodName, `("`, httpParam.Url, `", permission.RequireObjPermission("`, httpParam.Permission, `"), tmp.`, value.GoName, ")")
			} else {
				g.P("g.", httpParam.MethodName, `("`, httpParam.Url, `", tmp.`, value.GoName, ")")
			}

		}
		g.P("}")
		g.P()
		// 注册类型
		g.P("type ", service.GoName, " interface {")
		genService(gen, file, g, service, omitempty)
		g.P(" }")
	}
	g.P("// generated http handle")

	// 生成方法接口
	for _, service := range file.Services {
		g.P("type ", service.GoName, "HttpHandler", " interface {")
		genHttpService(gen, file, g, service, omitempty)
		g.P(" }")
		g.P()
	}

	// 生成对象
	// genHttpService implents
	for _, service := range file.Services {
		g.P("type ", "x_", service.GoName, " struct {")
		g.P("    xx ", service.GoName)
		g.P("}")
		g.P()
		genXService(gen, file, g, service, omitempty)
		g.P()
	}

}

func GetMessage(file *protogen.File, name string) *protogen.Message {
	for _, message := range file.Messages {
		if name == message.GoIdent.GoName {
			return message
		}
	}
	return nil
}
func JSONSnakeCase(s string) string {
	var b []byte
	if len(s) > 0 && 'A' <= s[0] && s[0] <= 'Z' {
		b = append(b, s[0]+'a'-'A')
	}
	for i := 1; i < len(s); i++ { // proto identifiers are always ASCII
		c := s[i]
		if 'A' <= c && c <= 'Z' {
			b = append(b, '_')
			c += 'a' - 'A' // convert to lowercase
		}
		b = append(b, c)
	}
	return string(b)
}

func fieldRequired(f *protogen.Field) bool {
	//	paramRe := regexp.MustCompile(`/<?(\w*):(\w+)>?`)
	//	re := regexp.MustCompile(`(?i)@url\s*:\s*(/.*/)`)
	//	urls := re.FindSubmatch([]byte(f.Comments.Leading.String()))
	//	if len(urls) > 1 {
	//		param.Url = strings.TrimSpace(string(urls[1]))
	//	}
	//	matchList := paramRe.FindAllSubmatch([]byte(f.Comments.Leading.String()), -1)
	//	for _, match := range matchList {
	//		pName := string(match[2])
	//		pType := string(match[1])
	//		if pType == "" {
	//			pType = StringType
	//		} else if pType == "str" || pType == StringType {
	//			pType = StringType
	//		} else if pType != IntType && pType != Int64Type && pType != UIntType {
	//			fmt.Fprintf(os.Stderr, "path param only support int and string/str, but get "+pType)
	//			os.Exit(0)
	//		}
	//		param.UrlParamList = append(param.UrlParamList, URLParam{
	//			pName: pName,
	//			pType: pType,
	//		})
	//	}
	return strings.Contains(f.Comments.Leading.String(), utils.Required)
}

func genXService(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile, service *protogen.Service, omitempty bool) {
	if service.Desc.Options().(*descriptorpb.ServiceOptions).GetDeprecated() {
		g.P("//")
		g.P(utils.DeprecationComment)
	}
	for _, value := range service.Methods {
		leading := value.Input.Comments.Leading.String()
		httpParam := utils.ParseRpcLeading(value.Comments.Leading.String(), value.GoName)
		if httpParam.Summary != "" {
			g.P("// @Summary ", httpParam.Summary)
		} else if len(leading) > 2 {
			g.P("// @Summary ", strings.TrimSpace(leading[2:]))
		}
		tagsName := strings.Replace(service.GoName, "Service", "-Service", 1)
		g.P("// @Tags ", tagsName)
		g.P("// @Produce json")
		for _, p := range httpParam.UrlParamList {
			g.P("// @Param ", p.PName, " path ", p.PType, " true ", `"some id"`)
		}
		for _, ff := range value.Input.Fields {
			query := "query"
			if httpParam.MethodName == "POST" || httpParam.MethodName == "PATCH" {
				query = "body"
			}
			fp := utils.ParseFieldLeading(ff)
			if len(fp.FTail) > 0 {
				g.P("// @Param ", fp.FName, " ", query, " ", fp.FType, " ", fp.FRequired, ` "`, fp.FTail, `" `, fp.GetEnums())
			} else {
				g.P("// @Param ", fp.FName, " ", query, " ", fp.FType, " ", fp.FRequired, ` "参数无注释" `, fp.GetEnums())
			}
		}

		if value.Output.GoIdent.GoName == "Empty" {
			g.P("// @Success 200 {object} object null")
		} else {
			g.P("// @Success 200 {object} ", value.Output.GoIdent.GoName)
		}
		g.P(`// @Failure 401 {string} string "header need Authorization data"`)
		g.P(`// @Failure 403 {string} string "no api permission or no obj permission"`)
		g.P("// @Router ", httpParam.Url, " [", httpParam.MethodName, "]")
		g.P("func (x *x_", service.GoName, ")", value.GoName, "(ctx *gin.Context)", "{")
		req := ""
		if value.Input.GoIdent.GoName != "CommonNil" && value.Input.GoIdent.GoName != "Empty" {
			req = ",req"
			g.P("  req := &", value.Input.GoIdent, "{}")
			if httpParam.MethodName == "GET" {
				g.P("  if err := ctx.ShouldBindQuery(req); err != nil {")
			} else {
				g.P("  if err := ctx.ShouldBindJSON(req); err != nil {")
			}
			g.P(` 	  ctx.JSON(http.StatusOK, gin.H{"code": 400, "detail":"request error"})`)
			g.P("     return")
			g.P("   }")

			//g.P("if err := gen.Validate.Struct(req); err != nil {")
			//g.P(` 	  ctx.JSON(http.StatusOK, gen.Response{400, " request param validator error", nil})`)
			//g.P("     return")
			//g.P("}")
		}
		if len(httpParam.UrlParamList) > 0 {
			var paramList []string
			for _, p := range httpParam.UrlParamList {
				if p.PType == utils.IntType || p.PType == utils.Int64Type || p.PType == utils.UIntType {
					if p.PType == utils.IntType {
						g.P(p.PName, `, err := strconv.Atoi(ctx.Param("`, p.PName, `"))`)
						g.P("if err != nil {")
						paramList = append(paramList, p.PName)
					} else if p.PType == utils.UIntType {
						paramList = append(paramList, fmt.Sprintf("uint(%s)", p.PName))
						g.P(p.PName, `, err := strconv.Atoi(ctx.Param("`, p.PName, `"))`)
						g.P("if err != nil || ", p.PName, " < 0", "{")
					} else {
						g.P(p.PName, `, err := strconv.ParseInt(ctx.Param("`, p.PName, `"), 10, 0)`)
						g.P("if err != nil {")
						paramList = append(paramList, p.PName)
					}
					g.P("    ctx.JSON(http.StatusBadRequest, gin.H{")
					g.P(`        "code": int(ErrCode_param_error),`)
					g.P(`        "detail": "param `, p.PName, ` should be int",`)
					g.P("    })")
					g.P("}")
				} else if p.PType == utils.StringType {
					g.P(p.PName, ` := ctx.Param("`, p.PName, `")`)
					paramList = append(paramList, p.PName)
				}
			}
			if !httpParam.Void {
				g.P("rsp, code := ", "x.xx.", value.GoName, "(ctx", req, ", ", strings.Join(paramList, ", "), ")")
			} else {
				g.P("_, _ = ", "x.xx.", value.GoName, "(ctx", req, ", ", strings.Join(paramList, ", "), ")")
			}
		} else {
			if !httpParam.Void {
				g.P("rsp, code := ", "x.xx.", value.GoName, "(ctx", req, ")")
			} else {
				g.P("_, _ = ", "x.xx.", value.GoName, "(ctx", req, ")")
			}
		}
		if !httpParam.Void {
			g.P("")
			g.P("ctx.JSON(http.StatusOK, gin.H{")
			g.P(`    "code": int(code),`)
			g.P(`    "detail": code.String(),`)
			g.P(`    "data": rsp,`)
			g.P("})")
		}
		g.P("}")
		g.P()
	}
}

func genService(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile, service *protogen.Service, omitempty bool) {
	if service.Desc.Options().(*descriptorpb.ServiceOptions).GetDeprecated() {
		g.P("//")
		g.P(utils.DeprecationComment)
	}
	for _, value := range service.Methods {
		inParam := ",in *" + value.Input.GoIdent.GoName
		if value.Input.GoIdent.GoName == "CommonNil" || value.Input.GoIdent.GoName == "Empty" {
			inParam = ""
		}
		httpParam := utils.ParseRpcLeading(value.Comments.Leading.String(), value.GoName)
		if len(httpParam.UrlParamList) > 0 {
			var paramList []string
			for _, p := range httpParam.UrlParamList {
				paramList = append(paramList, p.PName+" "+p.PType)
			}
			g.P(value.GoName, "(ctx *gin.Context ", inParam, ", ", strings.Join(paramList, ", "), ")", "(out ", "*", value.Output.GoIdent, ",code ErrCode", " )")
		} else {
			g.P(value.GoName, "(ctx *gin.Context ", inParam, ")", "(out ", "*", value.Output.GoIdent, ",code ErrCode", " )")
		}
	}
}

func genHttpService(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile, service *protogen.Service, omitempty bool) {
	if service.Desc.Options().(*descriptorpb.ServiceOptions).GetDeprecated() {
		g.P("//")
		g.P(utils.DeprecationComment)
	}
	for _, value := range service.Methods {

		g.P(value.GoName, "(ctx ", "*", "gin.Context", ")")
	}
}

// genImportService 读取本服务导入的包
func genImportService(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile, omitempty bool) []string {
	// 读取导入的包
	importPath := []string{}
	for _, v := range file.Services {
		// 读取注释
		serviceComments := string(v.Comments.Leading)
		if serviceComments == "" {
			continue
		}
		var commentsArr = []string{}
		if strings.Contains(serviceComments, "@") {
			// middleWares = parserComment(serviceComments)
			commentsArr = strings.Split(serviceComments, "@")
		}
		for _, c := range commentsArr {
			c = strings.TrimSpace(c)
			c = strings.TrimLeft(c, "\r\n")
			c = strings.TrimRight(c, "\r\n")
			if strings.HasPrefix(c, "import") {
				importPath = append(importPath, strings.Split(c, ":")[1])
				continue
			}
		}
	}
	return importPath
}

// ServiceInfo 服务的基本信息，包括组路由，中间件
type ServiceInfo struct {
	// 根路由
	ProjectUri string
	// 中间件
	MiddleWire string
	// 导包路径
	ImportPath []string
}

// parserComment 转化注释为字符串
func parserComment(comment []string) *ServiceInfo {
	si := &ServiceInfo{}
	var middleware string
	for _, c := range comment {
		c = strings.TrimSpace(c)
		c = strings.TrimLeft(c, "\r\n")
		c = strings.TrimRight(c, "\r\n")
		if strings.HasPrefix(c, "root") {
			si.ProjectUri = strings.Split(c, ":")[1]
			continue
		}
		if strings.HasPrefix(c, "middle") {
			middleware = strings.Split(c, ":")[1]
		}

	}
	si.MiddleWire = middleware
	return si

}
