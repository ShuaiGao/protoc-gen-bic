package internal

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"regexp"
	"strings"
	"unicode"
	"unicode/utf8"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"

	"google.golang.org/protobuf/types/descriptorpb"
	"google.golang.org/protobuf/types/pluginpb"
)

var (
	ImportPath = "import"
	VERSION    = "1.2.1"
)

// SupportedFeatures reports the set of supported protobuf language features.
var SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)
var PermissionPkg string

// GenerateFile generates the contents of a .pb.go file.
func GenerateFile(gen *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {
	return generateFile(gen, file, false)
}

func genImport(gen *protogen.Plugin, g *protogen.GeneratedFile, f *fileInfo, imp protoreflect.FileImport) {
	impFile, ok := gen.FilesByPath[imp.Path()]
	if !ok {
		return
	}
	if impFile.GoImportPath == f.GoImportPath {
		// Don't generate imports or aliases for types in the same Go package.
		return
	}
	// Generate imports for all non-weak dependencies, even if they are not
	// referenced, because other code and tools depend on having the
	// full transitive closure of protocol buffer types in the binary.
	if !imp.IsWeak {
		g.Import(impFile.GoImportPath)
	}
	if !imp.IsPublic {
		return
	}

	// Generate public imports by generating the imported file, parsing it,
	// and extracting every symbol that should receive a forwarding declaration.
	impGen := GenerateFile(gen, impFile)
	impGen.Skip()
	b, err := impGen.Content()
	if err != nil {
		gen.Error(err)
		return
	}
	fset := token.NewFileSet()
	astFile, err := parser.ParseFile(fset, "", b, parser.ParseComments)
	if err != nil {
		gen.Error(err)
		return
	}
	genForward := func(tok token.Token, name string, expr ast.Expr) {
		// Don't import unexported symbols.
		r, _ := utf8.DecodeRuneInString(name)
		if !unicode.IsUpper(r) {
			return
		}
		// Don't import the FileDescriptor.
		if name == impFile.GoDescriptorIdent.GoName {
			return
		}
		// Don't import decls referencing a symbol defined in another package.
		// i.e., don't import decls which are themselves public imports:
		//
		//	type T = somepackage.T
		if _, ok := expr.(*ast.SelectorExpr); ok {
			return
		}
		g.P(tok, " ", name, " = ", impFile.GoImportPath.Ident(name))
	}
	g.P("// Symbols defined in public import of ", imp.Path(), ".")
	g.P()
	for _, decl := range astFile.Decls {
		switch decl := decl.(type) {
		case *ast.GenDecl:
			for _, spec := range decl.Specs {
				switch spec := spec.(type) {
				case *ast.TypeSpec:
					genForward(decl.Tok, spec.Name.Name, spec.Type)
				case *ast.ValueSpec:
					for i, name := range spec.Names {
						var expr ast.Expr
						if i < len(spec.Values) {
							expr = spec.Values[i]
						}
						genForward(decl.Tok, name.Name, expr)
					}
				case *ast.ImportSpec:
				default:
					panic(fmt.Sprintf("can't generate forward for spec type %T", spec))
				}
			}
		}
	}
	g.P()
}

// generateFile generates a _http.pb.go file containing kratos errors definitions.
func generateFile(gen *protogen.Plugin, file *protogen.File, omitempty bool) *protogen.GeneratedFile {

	if len(file.Services) == 0 {
		return nil
	}
	filename := file.GeneratedFilenamePrefix + "_http.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	//f := newFileInfo(file)
	g.P("// Code generated by protoc-gen-bic. DO NOT EDIT.")
	g.P("// versions:", VERSION)
	//for i, imps := 0, f.Desc.Imports(); i < imps.Len(); i++ {
	//	genImport(gen, g, f, imps.Get(i))
	//}
	g.P()
	g.P("package ", string(file.GoPackageName))
	generateFileContent(gen, file, g, omitempty)
	return g
}

// generateFileContent generates the kratos errors definitions, excluding the package statement.
func generateFileContent(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile, omitempty bool) {
	if len(file.Services) == 0 {
		return
	}
	g.P("// This is a compile-time assertion to ensure that this generated file")
	g.P("// is compatible with the kratos package it is being compiled against.")
	g.P("import (")

	needImportPermission := false
	needImportStrconv := false
	for _, service := range file.Services {
		for _, value := range service.Methods {
			httpParam := parseRpcLeading(string(value.Comments.Leading), value.GoName)
			if len(httpParam.Permission) > 0 {
				needImportPermission = true
			}
			for _, param := range httpParam.UrlParamList {
				if param.pType == IntType || param.pType == Int64Type || param.pType == UIntType {
					needImportStrconv = true
				}
			}
		}
	}
	if needImportPermission {
		g.P(`"`, PermissionPkg, `"`)
	}

	g.P(`"net/http"`)

	if needImportStrconv {
		g.P(`"strconv"`)
	}

	paths := genImportService(gen, file, g, omitempty)
	for _, path := range paths {
		g.P(`"`, path, `"`)
	}
	g.P()
	g.P(`"github.com/gin-gonic/gin"`)
	//g.P(`"github.com/GodWY/bic/service"`)
	g.P(")")

	// 读取注释里的导入的包

	// 自动生成注册gin的何种方法
	for _, service := range file.Services {
		// 服务的注释
		serviceComments := string(service.Comments.Leading)
		// 获取服务组的middleWare
		var commentsArr = []string{}
		if strings.Contains(serviceComments, "@") {
			// middleWares = parserComment(serviceComments)
			commentsArr = strings.Split(serviceComments, "@")
		}
		si := parserComment(commentsArr)
		if si.ProjectUri == "" {
			si.ProjectUri = "/api"
		}
		g.P()
	}

	// 自动生成服务调用接口
	for _, service := range file.Services {
		g.P("func Register", service.GoName, "HttpHandler(g *gin.RouterGroup,", "srvs ", service.GoName, ") {")
		g.P("  tmp := &", "x_", service.GoName, "{ xx: srvs }")
		for _, value := range service.Methods {
			// g.Annotate(value.GoName, value.Location)
			// 读取注释
			// leadingComments := appendDeprecationSuffix("",
			// 	value.Desc.Options().(*descriptorpb.MethodOptions).GetDeprecated())
			a := string(value.Comments.Leading)
			httpParam := parseRpcLeading(a, value.GoName)
			// method := strings.Split(a, "@")
			// valuemiddleWares := parserComment(method[2:])
			if len(httpParam.Permission) > 0 {
				g.P("g.", httpParam.MethodName, `("`, httpParam.Url, `", permission.RequireObjPermission("`, httpParam.Permission, `"), tmp.`, value.GoName, ")")
			} else {
				g.P("g.", httpParam.MethodName, `("`, httpParam.Url, `", tmp.`, value.GoName, ")")
			}

		}
		g.P("}")
		g.P()
		// 注册类型
		g.P("type ", service.GoName, " interface {")
		genService(gen, file, g, service, omitempty)
		g.P(" }")
	}
	g.P("// generated http handle")

	// 生成方法接口
	for _, service := range file.Services {
		g.P("type ", service.GoName, "HttpHandler", " interface {")
		genHttpService(gen, file, g, service, omitempty)
		g.P(" }")
		g.P()
	}

	// 生成对象
	// genHttpService implents
	for _, service := range file.Services {
		g.P("type ", "x_", service.GoName, " struct {")
		g.P("    xx ", service.GoName)
		g.P("}")
		g.P()
		genXService(gen, file, g, service, omitempty)
		g.P()
	}

}

const StringType = "string"
const IntType = "int"
const UIntType = "uint"
const Int64Type = "int64"

type URLParam struct {
	pType string
	pName string
}

type ClientParam struct {
	Key   string
	Value string
}

type HTTPParam struct {
	Summary         string
	MethodName      string
	Url             string
	UrlParamList    []URLParam
	Permission      string
	Void            bool
	ClientParamList []ClientParam
	Download        bool
}

// parseRpcLeading 解析rpc方法注释
func parseRpcLeading(comm string, funcName string) (param HTTPParam) {
	param = HTTPParam{}
	supportMethods := []string{"GET", "POST", "DELETE", "PATCH"}

	for _, m := range supportMethods {
		// 匹配方法命名规则
		matched, err := regexp.MatchString(`(?i)`+m+`\w+`, funcName)
		if err == nil && matched {
			param.MethodName = m
			break
		}
	}
	// 优先使用 method标注
	for _, m := range supportMethods {
		matched, err := regexp.MatchString(`(?i)@method\s*:\s*`+m, comm)
		if err == nil && matched {
			param.MethodName = m
			break
		}
	}
	re := regexp.MustCompile(`(?i)@url\s*:\s*(/.*/)`)
	urls := re.FindSubmatch([]byte(comm))
	if len(urls) > 1 {
		param.Url = strings.TrimSpace(string(urls[1]))
	}
	paramRe := regexp.MustCompile(`/<?(\w*):(\w+)>?`)
	matchList := paramRe.FindAllSubmatch([]byte(param.Url), -1)
	for _, match := range matchList {
		pName := string(match[2])
		pType := string(match[1])
		if pType == "" {
			pType = StringType
		} else if pType == "str" || pType == StringType {
			pType = StringType
		} else if pType != IntType && pType != Int64Type && pType != UIntType {
			fmt.Fprintf(os.Stderr, "path param only support int and string/str, but get "+pType)
			os.Exit(0)
		}
		param.UrlParamList = append(param.UrlParamList, URLParam{
			pName: pName,
			pType: pType,
		})
	}
	delTypeRe := regexp.MustCompile(`<(\w+):(\w+)>`)
	param.Url = delTypeRe.ReplaceAllString(param.Url, ":$2")

	rePermission := regexp.MustCompile(`(?i)@permission\s*:\s*(\w*)`)
	objs := rePermission.FindSubmatch([]byte(comm))
	if len(objs) > 1 {
		param.Permission = strings.TrimSpace(string(objs[1]))
	}

	summaryPermission := regexp.MustCompile(`(?i)@summary\s*:\s*([^@$]*)`)
	summary := summaryPermission.FindSubmatch([]byte(comm))
	if len(summary) > 1 {
		param.Summary = strings.TrimSpace(string(summary[1]))
	}

	returnPermission := regexp.MustCompile(`(?i)@void`)
	void := returnPermission.FindSubmatch([]byte(comm))
	if len(void) > 0 {
		param.Void = true
	}

	downloadPermission := regexp.MustCompile(`(?i)@download`)
	download := downloadPermission.FindSubmatch([]byte(comm))
	if len(download) > 0 {
		param.Void = true
		param.Download = true
	}

	clientParam := regexp.MustCompile(`(?i)@cli-(\w+)\s*:\s*(["'a-zA-Z0-9]*)`)
	paramList := clientParam.FindAllSubmatch([]byte(comm), -1)
	for _, v := range paramList {
		if len(v) > 2 {
			param.ClientParamList = append(param.ClientParamList, ClientParam{
				Key:   string(v[1]),
				Value: string(v[2]),
			})
		}
	}
	return
}

func GetMessage(file *protogen.File, name string) *protogen.Message {
	for _, message := range file.Messages {
		if name == message.GoIdent.GoName {
			return message
		}
	}
	return nil
}
func JSONSnakeCase(s string) string {
	var b []byte
	if len(s) > 0 && 'A' <= s[0] && s[0] <= 'Z' {
		b = append(b, s[0]+'a'-'A')
	}
	for i := 1; i < len(s); i++ { // proto identifiers are always ASCII
		c := s[i]
		if 'A' <= c && c <= 'Z' {
			b = append(b, '_')
			c += 'a' - 'A' // convert to lowercase
		}
		b = append(b, c)
	}
	return string(b)
}

func fieldRequired(f *protogen.Field) bool {
	//	paramRe := regexp.MustCompile(`/<?(\w*):(\w+)>?`)
	//	re := regexp.MustCompile(`(?i)@url\s*:\s*(/.*/)`)
	//	urls := re.FindSubmatch([]byte(f.Comments.Leading.String()))
	//	if len(urls) > 1 {
	//		param.Url = strings.TrimSpace(string(urls[1]))
	//	}
	//	matchList := paramRe.FindAllSubmatch([]byte(f.Comments.Leading.String()), -1)
	//	for _, match := range matchList {
	//		pName := string(match[2])
	//		pType := string(match[1])
	//		if pType == "" {
	//			pType = StringType
	//		} else if pType == "str" || pType == StringType {
	//			pType = StringType
	//		} else if pType != IntType && pType != Int64Type && pType != UIntType {
	//			fmt.Fprintf(os.Stderr, "path param only support int and string/str, but get "+pType)
	//			os.Exit(0)
	//		}
	//		param.UrlParamList = append(param.UrlParamList, URLParam{
	//			pName: pName,
	//			pType: pType,
	//		})
	//	}
	return strings.Contains(f.Comments.Leading.String(), "required")
}

func genXService(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile, service *protogen.Service, omitempty bool) {
	if service.Desc.Options().(*descriptorpb.ServiceOptions).GetDeprecated() {
		g.P("//")
		g.P(deprecationComment)
	}
	for _, value := range service.Methods {
		leading := value.Input.Comments.Leading.String()
		httpParam := parseRpcLeading(value.Comments.Leading.String(), value.GoName)
		if httpParam.Summary != "" {
			g.P("// @Summary ", httpParam.Summary)
		} else if len(leading) > 2 {
			g.P("// @Summary ", strings.TrimSpace(leading[2:]))
		}
		tagsName := strings.Replace(service.GoName, "Service", "-Service", 1)
		g.P("// @Tags ", tagsName)
		g.P("// @Produce json")
		for _, p := range httpParam.UrlParamList {
			g.P("// @Param ", p.pName, " path ", p.pType, " true ", `"some id"`)
		}
		for _, ff := range value.Input.Fields {
			trailing := ff.Comments.Trailing.String()
			query := "query"
			if httpParam.MethodName == "POST" || httpParam.MethodName == "PATCH" {
				query = "body"
			}
			kindName := ff.Desc.Kind().String()
			if ff.Enum != nil {
				kindNames := strings.Split(string(ff.Enum.Desc.FullName()), ".")
				if len(kindNames) < 3 {
					kindName = string(ff.Enum.Desc.Name())
				} else {
					kindName = strings.Join(kindNames[1:], "_")
				}
			} else if ff.Desc.IsList() && ff.Desc.Message() != nil {
				kindName = fmt.Sprintf("[]%s", ff.Desc.Message().Name())
			}
			if kindName == "message" {
				kindName = string(ff.Desc.Message().Name())
				if kindName == "DataEntry" {
					// TODO 处理 map 类型
					kindName = "object"
				}
			} else if kindName == "bytes" {
				kindName = "[]byte"
			} else if kindName == "float" {
				kindName = "float32"
			} else if kindName == "double" {
				kindName = "float64"
			}
			if ff.Desc.IsList() {
				if ff.Desc.Enum() != nil {
					kindName = "int32"
				}
				if !strings.HasPrefix(kindName, "[]") {
					kindName = "[]" + kindName
				}
			}
			if len(trailing) > 2 {
				g.P("// @Param ", JSONSnakeCase(ff.GoName), " ", query, " ", kindName, " ", fieldRequired(ff), ` "`, strings.TrimSpace(ff.Comments.Trailing.String()[2:]), `"`)
			} else {
				g.P("// @Param ", JSONSnakeCase(ff.GoName), " ", query, " ", kindName, " ", fieldRequired(ff), ` "参数无注释"`)
			}
		}
		g.P("// @Success 200 {object} ", value.Output.GoIdent.GoName)
		g.P(`// @Failure 401 {string} string "header need Authorization data"`)
		g.P(`// @Failure 403 {string} string "no api permission or no obj permission"`)
		g.P("// @Router ", httpParam.Url, " [", httpParam.MethodName, "]")
		g.P("func (x *x_", service.GoName, ")", value.GoName, "(ctx *gin.Context)", "{")
		req := ""
		if value.Input.GoIdent.GoName != "CommonNil" {
			req = ",req"
			g.P("  req := &", value.Input.GoIdent, "{}")
			if httpParam.MethodName == "GET" {
				g.P("  if err := ctx.ShouldBindQuery(req); err != nil {")
			} else {
				g.P("  if err := ctx.Bind(req); err != nil {")
			}
			g.P(` 	  ctx.JSON(http.StatusOK, gin.H{"code": 400, "detail":" request error"})`)
			g.P("     return")
			g.P("   }")

			//g.P("if err := gen.Validate.Struct(req); err != nil {")
			//g.P(` 	  ctx.JSON(http.StatusOK, gen.Response{400, " request param validator error", nil})`)
			//g.P("     return")
			//g.P("}")
		}
		if len(httpParam.UrlParamList) > 0 {
			var paramList []string
			for _, p := range httpParam.UrlParamList {
				if p.pType == IntType || p.pType == Int64Type || p.pType == UIntType {
					if p.pType == IntType {
						g.P(p.pName, `, err := strconv.Atoi(ctx.Param("`, p.pName, `"))`)
						g.P("if err != nil {")
						paramList = append(paramList, p.pName)
					} else if p.pType == UIntType {
						paramList = append(paramList, fmt.Sprintf("uint(%s)", p.pName))
						g.P(p.pName, `, err := strconv.Atoi(ctx.Param("`, p.pName, `"))`)
						g.P("if err != nil || ", p.pName, " < 0", "{")
					} else {
						g.P(p.pName, `, err := strconv.ParseInt(ctx.Param("`, p.pName, `"), 10, 0)`)
						g.P("if err != nil {")
						paramList = append(paramList, p.pName)
					}
					g.P("    ctx.JSON(http.StatusBadRequest, gin.H{")
					g.P(`        "code": int(ErrCode_param_error),`)
					g.P(`        "detail": "param `, p.pName, ` should be int",`)
					g.P("    })")
					g.P("}")
				} else if p.pType == StringType {
					g.P(p.pName, ` := ctx.Param("`, p.pName, `")`)
					paramList = append(paramList, p.pName)
				}
			}
			if !httpParam.Void {
				g.P("rsp, code := ", "x.xx.", value.GoName, "(ctx", req, ", ", strings.Join(paramList, ", "), ")")
			} else {
				g.P("_, _ = ", "x.xx.", value.GoName, "(ctx", req, ", ", strings.Join(paramList, ", "), ")")
			}
		} else {
			if !httpParam.Void {
				g.P("rsp, code := ", "x.xx.", value.GoName, "(ctx", req, ")")
			} else {
				g.P("_, _ = ", "x.xx.", value.GoName, "(ctx", req, ")")
			}
		}
		if !httpParam.Void {
			g.P("")
			g.P("ctx.JSON(http.StatusOK, gin.H{")
			g.P(`    "code": int(code),`)
			g.P(`    "detail": code.String(),`)
			g.P(`    "data": rsp,`)
			g.P("})")
		}
		g.P("}")
		g.P()
	}
}

func genService(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile, service *protogen.Service, omitempty bool) {
	if service.Desc.Options().(*descriptorpb.ServiceOptions).GetDeprecated() {
		g.P("//")
		g.P(deprecationComment)
	}
	for _, value := range service.Methods {
		inParam := ",in *" + value.Input.GoIdent.GoName
		if value.Input.GoIdent.GoName == "CommonNil" {
			inParam = ""
		}
		httpParam := parseRpcLeading(value.Comments.Leading.String(), value.GoName)
		if len(httpParam.UrlParamList) > 0 {
			var paramList []string
			for _, p := range httpParam.UrlParamList {
				paramList = append(paramList, p.pName+" "+p.pType)
			}
			g.P(value.GoName, "(ctx *gin.Context ", inParam, ", ", strings.Join(paramList, ", "), ")", "(out ", "*", value.Output.GoIdent, ",code ErrCode", " )")
		} else {
			g.P(value.GoName, "(ctx *gin.Context ", inParam, ")", "(out ", "*", value.Output.GoIdent, ",code ErrCode", " )")
		}
	}
}

func genHttpService(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile, service *protogen.Service, omitempty bool) {
	if service.Desc.Options().(*descriptorpb.ServiceOptions).GetDeprecated() {
		g.P("//")
		g.P(deprecationComment)
	}
	for _, value := range service.Methods {

		g.P(value.GoName, "(ctx ", "*", "gin.Context", ")")
	}
}

// genImportService 读取本服务导入的包
func genImportService(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile, omitempty bool) []string {
	// 读取导入的包
	importPath := []string{}
	for _, v := range file.Services {
		// 读取注释
		serviceComments := string(v.Comments.Leading)
		if serviceComments == "" {
			continue
		}
		var commentsArr = []string{}
		if strings.Contains(serviceComments, "@") {
			// middleWares = parserComment(serviceComments)
			commentsArr = strings.Split(serviceComments, "@")
		}
		for _, c := range commentsArr {
			c = strings.TrimSpace(c)
			c = strings.TrimLeft(c, "\r\n")
			c = strings.TrimRight(c, "\r\n")
			if strings.HasPrefix(c, "import") {
				importPath = append(importPath, strings.Split(c, ":")[1])
				continue
			}
		}
	}
	return importPath
}

const deprecationComment = "// Deprecated: Do not use."

// ServiceInfo 服务的基本信息，包括组路由，中间件
type ServiceInfo struct {
	// 根路由
	ProjectUri string
	// 中间件
	MiddleWire string
	// 导包路径
	ImportPath []string
}

// parserComment 转化注释为字符串
func parserComment(comment []string) *ServiceInfo {
	si := &ServiceInfo{}
	var middleware string
	for _, c := range comment {
		c = strings.TrimSpace(c)
		c = strings.TrimLeft(c, "\r\n")
		c = strings.TrimRight(c, "\r\n")
		if strings.HasPrefix(c, "root") {
			si.ProjectUri = strings.Split(c, ":")[1]
			continue
		}
		if strings.HasPrefix(c, "middle") {
			middleware = strings.Split(c, ":")[1]
		}

	}
	si.MiddleWire = middleware
	return si

}
